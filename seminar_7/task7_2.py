# Планеты вращаются вокруг звезд по эллиптическим орбитам.
# Назовем самой далекой планетой ту, орбита которой имеет
# самую большую площадь. Напишите функцию
# find_farthest_orbit(list_of_orbits), которая среди списка орбит
# планет найдет ту, по которой вращается самая далекая
# планета. Круговые орбиты не учитывайте: вы знаете, что у
# вашей звезды таких планет нет, зато искусственные спутники
# были были запущены на круговые орбиты. Результатом
# функции должен быть кортеж, содержащий длины полуосей
# эллипса орбиты самой далекой планеты. Каждая орбита
# представляет из себя кортеж из пары чисел - полуосей ее
# эллипса. Площадь эллипса вычисляется по формуле S = pi*a*b,
# где a и b - длины полуосей эллипса. При решении задачи
# используйте списочные выражения. Подсказка: проще всего
# будет найти эллипс в два шага: сначала вычислить самую
# большую площадь эллипса, а затем найти и сам эллипс,
# имеющий такую площадь. Гарантируется, что самая далекая
# планета ровно одна

# ВАРИАНТ1
# def find_farthest_orbit(orb):
#     max_orb = -1
#     i_max = 0
#     lst_s = []
#     for a,b in orb:
#         if a==b:
#             continue
#         s = a * b
#         lst_s.append(s)
#     for i in range(len(lst_s)):
#         if lst_s[i] ==  max(lst_s):
#             i_max = i
#     return orb[i_max]

# ВАРИАНТ2
# def find_farthest_orbit(orb):
#     max_orb = -1
#     for i,p in enumerate(orb):
#         a,b = p
#         if a==b:
#             continue
#         s = a * b
#         if s > max_orb:
#             max_orb = s
#             i_max = i
#     return orb[i_max]

# ВАРИАНТ3
# def find_farthest_orbit(orb):
#     orb = list(filter(lambda p: p[0] != p[1], orb)) # создали список без одинаковых а и в
#     max_orb = list(map(lambda p: p[0] * p[1], orb)) # создали список с площадями эллипсов
#     return orb[max_orb.index(max(max_orb))]         # выдернули значение из первого списка с индексом, который соответствует максимальному значению в списке площадей

# ВАРИАНТ4
def find_farthest_orbit(orb):
    orb = {p[0] * p[1] if p[0] != p[1] else 0 : p for p in orb} #создали словарь с ключем равным площади, если а и в равны площадь о) и значением равным паре эллипсов
    return orb[max(orb.keys())] # из словаря достали значение для максимального ключа

orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
print(*find_farthest_orbit(orbits))
